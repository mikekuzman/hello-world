<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>4D Quantum Superfluid Visualizer</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #000;
        }
        #info {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            background: rgba(0, 0, 0, 0.8);
            padding: 15px;
            border-radius: 5px;
            font-size: 13px;
            max-width: 340px;
            z-index: 100;
            border: 1px solid #333;
        }
        #controls {
            position: absolute;
            top: 10px;
            right: 10px;
            color: white;
            background: rgba(0, 0, 0, 0.8);
            padding: 15px;
            border-radius: 5px;
            z-index: 100;
            max-width: 300px;
            border: 1px solid #333;
        }
        #fileUpload {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.9);
            padding: 40px;
            border-radius: 10px;
            border: 2px solid #4CAF50;
            text-align: center;
            z-index: 200;
        }
        #fileUpload h2 {
            margin-top: 0;
            color: #4CAF50;
        }
        #fileUpload p {
            color: #aaa;
            margin: 10px 0;
        }
        input[type="file"] {
            margin: 20px 0;
            padding: 10px;
            background: #222;
            color: white;
            border: 1px solid #555;
            border-radius: 5px;
            cursor: pointer;
        }
        button {
            margin: 5px 0;
            padding: 8px 12px;
            cursor: pointer;
            background: #4CAF50;
            color: white;
            border: none;
            border-radius: 3px;
            width: 100%;
            font-size: 13px;
        }
        button:hover {
            background: #45a049;
        }
        button:disabled {
            background: #555;
            cursor: not-allowed;
        }
        select, input[type="range"] {
            margin: 5px 0;
            padding: 6px;
            width: 100%;
            border-radius: 3px;
            background: #222;
            color: white;
            border: 1px solid #555;
        }
        .slider-container {
            margin: 10px 0;
        }
        .slider-label {
            font-size: 11px;
            color: #ccc;
            margin-bottom: 3px;
        }
        .section-title {
            font-size: 12px;
            font-weight: bold;
            margin-top: 15px;
            margin-bottom: 8px;
            color: #4CAF50;
            border-bottom: 1px solid #333;
            padding-bottom: 3px;
        }
        .stat-row {
            display: flex;
            justify-content: space-between;
            margin: 4px 0;
            font-size: 12px;
        }
        .stat-label {
            color: #888;
        }
        .stat-value {
            color: #fff;
            font-weight: bold;
        }
        #loadingIndicator {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #4CAF50;
            font-size: 18px;
            background: rgba(0,0,0,0.9);
            padding: 20px 40px;
            border-radius: 5px;
            display: none;
            z-index: 300;
        }
    </style>
</head>
<body>
    <div id="fileUpload">
        <h2>4D Quantum Superfluid Visualizer</h2>
        <p>Load a simulation snapshot (JSON format v005)</p>
        <input type="file" id="fileInput" accept=".json">
        <p style="font-size: 11px; color: #666;">
            Expected format: snapshot_set_v005<br>
            Generated by sim_v005.py
        </p>
    </div>

    <div id="loadingIndicator">Loading simulation data...</div>

    <div id="info" style="display: none;">
        <h3 style="margin-top: 0; color: #4CAF50;">Quantum Superfluid</h3>
        <div class="stat-row">
            <span class="stat-label">Snapshot:</span>
            <span class="stat-value"><span id="currentSnapshot">0</span> / <span id="totalSnapshots">0</span></span>
        </div>
        <div class="stat-row">
            <span class="stat-label">Time Step:</span>
            <span class="stat-value" id="timeStep">0</span>
        </div>
        <div class="stat-row">
            <span class="stat-label">Fluid Points:</span>
            <span class="stat-value" id="fluidPoints">0</span>
        </div>
        <div class="stat-row">
            <span class="stat-label">Vortices:</span>
            <span class="stat-value" id="vortexCount">0</span>
        </div>
        <div class="stat-row">
            <span class="stat-label">Sound Speed:</span>
            <span class="stat-value" id="soundSpeed">-</span>
        </div>
        <div class="stat-row">
            <span class="stat-label">Healing Length:</span>
            <span class="stat-value" id="healingLength">-</span>
        </div>
        <p style="font-size: 11px; color: #666; margin-top: 10px; border-top: 1px solid #333; padding-top: 8px;">
            <strong>Superfluid Color:</strong> Phase angle<br>
            <strong>Brightness:</strong> Local density<br>
            <strong>Vortices:</strong> Black cores (topological defects)<br>
            <span style="color: #ff4444;">Red = Northern hemisphere</span> (w &gt; 0)<br>
            <span style="color: #4488ff;">Blue = Southern hemisphere</span> (w &lt; 0)
        </p>
    </div>

    <div id="controls" style="display: none;">
        <h4 style="margin-top: 0;">Viewing Controls</h4>

        <div class="section-title">Snapshot Playback</div>
        <div class="slider-container">
            <div class="slider-label">Snapshot: <span id="snapshotLabel">0</span></div>
            <input type="range" id="snapshotSlider" min="0" max="0" value="0" step="1">
        </div>
        <button id="playPause">▶ Play</button>

        <div class="section-title">4D Viewing Angle</div>
        <p style="font-size: 10px; color: #888; margin: 5px 0;">Rotate the frozen superfluid in 4D space</p>
        <div class="slider-container">
            <div class="slider-label">XW Rotation: <span id="xwValue">0.0</span></div>
            <input type="range" id="rotationXW" min="0" max="6.28" step="0.01" value="0">
        </div>
        <div class="slider-container">
            <div class="slider-label">YW Rotation: <span id="ywValue">0.0</span></div>
            <input type="range" id="rotationYW" min="0" max="6.28" step="0.01" value="0">
        </div>
        <div class="slider-container">
            <div class="slider-label">ZW Rotation: <span id="zwValue">0.0</span></div>
            <input type="range" id="rotationZW" min="0" max="6.28" step="0.01" value="0">
        </div>
        <button id="resetView">Reset View</button>

        <div class="section-title">Display</div>
        <div class="slider-container">
            <div class="slider-label">Point Size: <span id="sizeValue">2</span></div>
            <input type="range" id="pointSize" min="1" max="8" value="2" step="0.5">
        </div>
        <div class="slider-container">
            <div class="slider-label">Vortex Size: <span id="vortexSizeValue">3</span></div>
            <input type="range" id="vortexSize" min="1" max="10" value="3" step="0.5">
        </div>
        <label>
            <input type="checkbox" id="showPoles" checked> Show 4D Poles
        </label>

        <div class="section-title">Projection</div>
        <select id="projectionSelect">
            <option value="perspective" selected>Perspective</option>
            <option value="stereographic">Stereographic</option>
            <option value="orthogonal">Orthogonal</option>
        </select>

        <p style="font-size: 10px; color: #666; margin-top: 15px; border-top: 1px solid #333; padding-top: 8px;">
            Mouse: Rotate View | Scroll: Zoom
        </p>
    </div>

    <script type="importmap">
    {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
        }
    }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { CSS2DRenderer, CSS2DObject } from 'three/addons/renderers/CSS2DRenderer.js';

        // Scene setup
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x0a0a0a);

        const camera = new THREE.PerspectiveCamera(
            75,
            window.innerWidth / window.innerHeight,
            0.1,
            2000
        );
        camera.position.z = 5;

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        const labelRenderer = new CSS2DRenderer();
        labelRenderer.setSize(window.innerWidth, window.innerHeight);
        labelRenderer.domElement.style.position = 'absolute';
        labelRenderer.domElement.style.top = '0px';
        labelRenderer.domElement.style.pointerEvents = 'none';
        document.body.appendChild(labelRenderer.domElement);

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;

        // Lighting
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);

        const pointLight1 = new THREE.PointLight(0xffffff, 0.8);
        pointLight1.position.set(10, 10, 10);
        scene.add(pointLight1);

        const pointLight2 = new THREE.PointLight(0x4488ff, 0.4);
        pointLight2.position.set(-10, -10, -10);
        scene.add(pointLight2);

        // Global state
        let simulationData = null;
        let currentSnapshotIndex = 0;
        let isPlaying = false;
        let playbackInterval = null;

        let sceneGroup = new THREE.Group();
        scene.add(sceneGroup);

        let superfluidPoints = null;
        let vortexGroup = null;
        let northPoleMesh = null;
        let southPoleMesh = null;

        // 4D viewing angles (user-controlled perspective)
        let viewAngles = {
            xw: 0,
            yw: 0,
            zw: 0
        };

        // Projection distance scaled to match simulation coordinates (~1000)
        let projectionDistance = 2500; // 2.5 * 1000
        let sphereRadius = 1.0; // Will be updated from simulation data

        // NOTE for v2: Add global subsampling parameter here
        // let subsampleFactor = 1;

        // 4D Rotation matrices (for viewing angle only)
        function rotationMatrix4D_XW(angle) {
            const c = Math.cos(angle);
            const s = Math.sin(angle);
            return [
                [c,  0,  0, -s],
                [0,  1,  0,  0],
                [0,  0,  1,  0],
                [s,  0,  0,  c]
            ];
        }

        function rotationMatrix4D_YW(angle) {
            const c = Math.cos(angle);
            const s = Math.sin(angle);
            return [
                [1,  0,  0,  0],
                [0,  c,  0, -s],
                [0,  0,  1,  0],
                [0,  s,  0,  c]
            ];
        }

        function rotationMatrix4D_ZW(angle) {
            const c = Math.cos(angle);
            const s = Math.sin(angle);
            return [
                [1,  0,  0,  0],
                [0,  1,  0,  0],
                [0,  0,  c, -s],
                [0,  0,  s,  c]
            ];
        }

        function multiplyMatrices4D(A, B) {
            const result = Array(4).fill(0).map(() => Array(4).fill(0));
            for (let i = 0; i < 4; i++) {
                for (let j = 0; j < 4; j++) {
                    for (let k = 0; k < 4; k++) {
                        result[i][j] += A[i][k] * B[k][j];
                    }
                }
            }
            return result;
        }

        function applyMatrix4D(matrix, point) {
            return [
                matrix[0][0] * point[0] + matrix[0][1] * point[1] + matrix[0][2] * point[2] + matrix[0][3] * point[3],
                matrix[1][0] * point[0] + matrix[1][1] * point[1] + matrix[1][2] * point[2] + matrix[1][3] * point[3],
                matrix[2][0] * point[0] + matrix[2][1] * point[1] + matrix[2][2] * point[2] + matrix[2][3] * point[3],
                matrix[3][0] * point[0] + matrix[3][1] * point[1] + matrix[3][2] * point[2] + matrix[3][3] * point[3]
            ];
        }

        function rotatePoints4D(points, angleXW, angleYW, angleZW) {
            const R_xw = rotationMatrix4D_XW(angleXW);
            const R_yw = rotationMatrix4D_YW(angleYW);
            const R_zw = rotationMatrix4D_ZW(angleZW);

            let R = multiplyMatrices4D(R_xw, R_yw);
            R = multiplyMatrices4D(R, R_zw);

            return points.map(p => applyMatrix4D(R, p));
        }

        // Projection functions
        function projectPerspective(point4D, distance) {
            const scale = distance / (distance - point4D[3]);
            return [
                point4D[0] * scale,
                point4D[1] * scale,
                point4D[2] * scale
            ];
        }

        function projectStereographic(point4D, radius) {
            const scale = radius / (radius - point4D[3]);
            return [
                point4D[0] * scale,
                point4D[1] * scale,
                point4D[2] * scale
            ];
        }

        function projectOrthogonal(point4D) {
            return [point4D[0], point4D[1], point4D[2]];
        }

        // Load simulation data
        function loadSimulationData(jsonData) {
            console.log("Loading simulation data...");

            if (jsonData.format !== 'snapshot_set_v005') {
                alert('Unsupported format! Please use v005 snapshot files.');
                return false;
            }

            simulationData = jsonData;
            currentSnapshotIndex = 0;

            // Update UI
            document.getElementById('totalSnapshots').textContent = simulationData.snapshots.length;
            document.getElementById('snapshotSlider').max = simulationData.snapshots.length - 1;

            // Extract sphere radius from first snapshot
            const firstSnapshot = simulationData.snapshots[0];
            sphereRadius = simulationData.parameters.R; // Keep at simulation scale!

            console.log(`Loaded ${simulationData.snapshots.length} snapshots`);
            console.log(`Sphere radius (4D): ${sphereRadius}`);

            // Show UI
            document.getElementById('fileUpload').style.display = 'none';
            document.getElementById('info').style.display = 'block';
            document.getElementById('controls').style.display = 'block';

            // Create poles
            createPoles();

            // Render first snapshot
            renderSnapshot(0);

            return true;
        }

        // Render a specific snapshot
        function renderSnapshot(index) {
            if (!simulationData || index < 0 || index >= simulationData.snapshots.length) {
                return;
            }

            currentSnapshotIndex = index;
            const snapshot = simulationData.snapshots[index];

            // Update info panel
            document.getElementById('currentSnapshot').textContent = index + 1;
            document.getElementById('timeStep').textContent = snapshot.metadata.step;
            document.getElementById('fluidPoints').textContent = snapshot.metadata.n_points.toLocaleString();
            document.getElementById('vortexCount').textContent = snapshot.metadata.n_vortices;
            document.getElementById('soundSpeed').textContent = snapshot.phonons.sound_speed.toFixed(3);
            document.getElementById('healingLength').textContent = snapshot.phonons.healing_length.toFixed(2);
            document.getElementById('snapshotLabel').textContent = index + 1;

            // Render superfluid
            renderSuperfluid(snapshot);

            // Render vortices
            renderVortices(snapshot);

            // Update view
            updateView();
        }

        // Render superfluid points
        function renderSuperfluid(snapshot) {
            // Remove old points
            if (superfluidPoints) {
                sceneGroup.remove(superfluidPoints);
            }

            const positions = snapshot.superfluid.positions;
            const density = snapshot.superfluid.density;
            const phase = snapshot.superfluid.phase;

            // Use statistics for density normalization
            const densityMin = snapshot.statistics.density.p5;
            const densityMax = snapshot.statistics.density.p95;

            const geometry = new THREE.BufferGeometry();
            const pos3D = [];
            const colors = [];
            const sizes = [];

            // Initial projection (will be updated by viewing angle)
            for (let i = 0; i < positions.length; i++) {
                const pos4D = positions[i];
                const pos3 = projectPerspective(pos4D, projectionDistance);

                pos3D.push(pos3[0] / 1000, pos3[1] / 1000, pos3[2] / 1000);

                // Color from phase (hue cycle)
                const hue = phase[i]; // Already normalized to [0, 1]
                const color = new THREE.Color();
                color.setHSL(hue, 1.0, 0.5);
                colors.push(color.r, color.g, color.b);

                // Size from density
                const densityNorm = (density[i] - densityMin) / (densityMax - densityMin + 1e-6);
                const size = Math.max(0.1, Math.min(1.0, densityNorm));
                sizes.push(size);
            }

            geometry.setAttribute('position', new THREE.Float32BufferAttribute(pos3D, 3));
            geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
            geometry.setAttribute('size', new THREE.Float32BufferAttribute(sizes, 1));

            const material = new THREE.PointsMaterial({
                vertexColors: true,
                size: parseFloat(document.getElementById('pointSize').value) * 0.01,
                sizeAttenuation: true,
                transparent: true,
                opacity: 0.8
            });

            superfluidPoints = new THREE.Points(geometry, material);
            superfluidPoints.userData.positions4D = positions;
            superfluidPoints.userData.phase = phase;
            superfluidPoints.userData.density = density;
            superfluidPoints.userData.densityMin = densityMin;
            superfluidPoints.userData.densityMax = densityMax;

            sceneGroup.add(superfluidPoints);
        }

        // Render vortices (simple black spheres with white border)
        function renderVortices(snapshot) {
            // Remove old vortices
            if (vortexGroup) {
                sceneGroup.remove(vortexGroup);
            }

            vortexGroup = new THREE.Group();

            const vortices = snapshot.vortices.data;
            if (vortices.length === 0) {
                sceneGroup.add(vortexGroup);
                return;
            }

            const vortexSizeParam = parseFloat(document.getElementById('vortexSize').value);

            vortices.forEach(vortex => {
                const pos4D = vortex.position;

                // Determine hemisphere based on w-coordinate (4th dimension)
                const w_coord = pos4D[3];
                const isNorthern = w_coord >= 0;

                // Hemisphere colors: Red = North (w > 0), Blue = South (w < 0)
                const hemisphereColor = isNorthern ? 0xff0000 : 0x0088ff;
                const hemisphereName = isNorthern ? 'N' : 'S';

                // Create black core with hemisphere-colored glow
                const coreGeometry = new THREE.SphereGeometry(0.03 * vortexSizeParam, 16, 16);
                const coreMaterial = new THREE.MeshStandardMaterial({
                    color: 0x000000,
                    emissive: hemisphereColor,
                    emissiveIntensity: 0.3,
                    metalness: 0.8,
                    roughness: 0.2
                });
                const coreMesh = new THREE.Mesh(coreGeometry, coreMaterial);

                // Create hemisphere-colored border (wireframe)
                const borderGeometry = new THREE.SphereGeometry(0.035 * vortexSizeParam, 16, 16);
                const borderMaterial = new THREE.MeshBasicMaterial({
                    color: hemisphereColor,
                    wireframe: true,
                    transparent: true,
                    opacity: 0.8
                });
                const borderMesh = new THREE.Mesh(borderGeometry, borderMaterial);

                const vortexContainer = new THREE.Group();
                vortexContainer.add(coreMesh);
                vortexContainer.add(borderMesh);
                vortexContainer.userData.position4D = pos4D;
                vortexContainer.userData.hemisphere = hemisphereName;

                vortexGroup.add(vortexContainer);
            });

            sceneGroup.add(vortexGroup);
        }

        // Create 4D poles
        function createPoles() {
            if (northPoleMesh) {
                sceneGroup.remove(northPoleMesh);
            }
            if (southPoleMesh) {
                sceneGroup.remove(southPoleMesh);
            }

            const poleGeometry = new THREE.SphereGeometry(0.04, 16, 16);

            const northPoleMaterial = new THREE.MeshStandardMaterial({
                color: 0xff0000,
                emissive: 0xff0000,
                emissiveIntensity: 0.5,
                metalness: 0.3,
                roughness: 0.4
            });
            northPoleMesh = new THREE.Mesh(poleGeometry, northPoleMaterial);
            northPoleMesh.userData.position4D = [0, 0, 0, sphereRadius];

            const northLabelDiv = document.createElement('div');
            northLabelDiv.textContent = 'N';
            northLabelDiv.style.color = '#ff0000';
            northLabelDiv.style.fontFamily = 'Arial, sans-serif';
            northLabelDiv.style.fontSize = '24px';
            northLabelDiv.style.fontWeight = 'bold';
            northLabelDiv.style.textShadow = '0 0 4px black, 0 0 8px black';
            const northLabel = new CSS2DObject(northLabelDiv);
            northLabel.position.set(0, 0.08, 0);
            northPoleMesh.add(northLabel);

            const southPoleMaterial = new THREE.MeshStandardMaterial({
                color: 0x0088ff,
                emissive: 0x0088ff,
                emissiveIntensity: 0.5,
                metalness: 0.3,
                roughness: 0.4
            });
            southPoleMesh = new THREE.Mesh(poleGeometry, southPoleMaterial);
            southPoleMesh.userData.position4D = [0, 0, 0, -sphereRadius];

            const southLabelDiv = document.createElement('div');
            southLabelDiv.textContent = 'S';
            southLabelDiv.style.color = '#0088ff';
            southLabelDiv.style.fontFamily = 'Arial, sans-serif';
            southLabelDiv.style.fontSize = '24px';
            southLabelDiv.style.fontWeight = 'bold';
            southLabelDiv.style.textShadow = '0 0 4px black, 0 0 8px black';
            const southLabel = new CSS2DObject(southLabelDiv);
            southLabel.position.set(0, 0.08, 0);
            southPoleMesh.add(southLabel);

            sceneGroup.add(northPoleMesh);
            sceneGroup.add(southPoleMesh);
        }

        // Update view based on 4D viewing angles
        function updateView() {
            if (!simulationData) return;

            const projectionType = document.getElementById('projectionSelect').value;

            // Update superfluid points
            if (superfluidPoints) {
                const positions4D = superfluidPoints.userData.positions4D;
                const phase = superfluidPoints.userData.phase;
                const density = superfluidPoints.userData.density;
                const densityMin = superfluidPoints.userData.densityMin;
                const densityMax = superfluidPoints.userData.densityMax;

                // Rotate in 4D (viewing angle)
                const rotated4D = rotatePoints4D(positions4D, viewAngles.xw, viewAngles.yw, viewAngles.zw);

                // Project to 3D
                const positions = superfluidPoints.geometry.attributes.position;
                const colors = superfluidPoints.geometry.attributes.color;
                const sizes = superfluidPoints.geometry.attributes.size;

                for (let i = 0; i < rotated4D.length; i++) {
                    let pos3D;
                    if (projectionType === 'perspective') {
                        pos3D = projectPerspective(rotated4D[i], projectionDistance);
                    } else if (projectionType === 'stereographic') {
                        pos3D = projectStereographic(rotated4D[i], sphereRadius);
                    } else {
                        pos3D = projectOrthogonal(rotated4D[i]);
                    }

                    positions.array[i * 3] = pos3D[0] / 1000;
                    positions.array[i * 3 + 1] = pos3D[1] / 1000;
                    positions.array[i * 3 + 2] = pos3D[2] / 1000;

                    // Update color from phase
                    const hue = phase[i];
                    const color = new THREE.Color();
                    color.setHSL(hue, 1.0, 0.5);
                    colors.array[i * 3] = color.r;
                    colors.array[i * 3 + 1] = color.g;
                    colors.array[i * 3 + 2] = color.b;

                    // Update size from density
                    const densityNorm = (density[i] - densityMin) / (densityMax - densityMin + 1e-6);
                    sizes.array[i] = Math.max(0.1, Math.min(1.0, densityNorm));
                }

                positions.needsUpdate = true;
                colors.needsUpdate = true;
                sizes.needsUpdate = true;
            }

            // Update vortices
            if (vortexGroup) {
                vortexGroup.children.forEach(vortexContainer => {
                    const pos4D = vortexContainer.userData.position4D;
                    const rotated = rotatePoints4D([pos4D], viewAngles.xw, viewAngles.yw, viewAngles.zw)[0];

                    let pos3D;
                    if (projectionType === 'perspective') {
                        pos3D = projectPerspective(rotated, projectionDistance);
                    } else if (projectionType === 'stereographic') {
                        pos3D = projectStereographic(rotated, sphereRadius);
                    } else {
                        pos3D = projectOrthogonal(rotated);
                    }

                    vortexContainer.position.set(pos3D[0] / 1000, pos3D[1] / 1000, pos3D[2] / 1000);
                });
            }

            // Update poles
            const showPoles = document.getElementById('showPoles').checked;
            if (northPoleMesh) {
                northPoleMesh.visible = showPoles;
                if (showPoles) {
                    const rotated = rotatePoints4D([northPoleMesh.userData.position4D], viewAngles.xw, viewAngles.yw, viewAngles.zw)[0];
                    let pos3D;
                    if (projectionType === 'perspective') {
                        pos3D = projectPerspective(rotated, projectionDistance);
                    } else if (projectionType === 'stereographic') {
                        pos3D = projectStereographic(rotated, sphereRadius);
                    } else {
                        pos3D = projectOrthogonal(rotated);
                    }
                    northPoleMesh.position.set(pos3D[0] / 1000, pos3D[1] / 1000, pos3D[2] / 1000);
                }
            }

            if (southPoleMesh) {
                southPoleMesh.visible = showPoles;
                if (showPoles) {
                    const rotated = rotatePoints4D([southPoleMesh.userData.position4D], viewAngles.xw, viewAngles.yw, viewAngles.zw)[0];
                    let pos3D;
                    if (projectionType === 'perspective') {
                        pos3D = projectPerspective(rotated, projectionDistance);
                    } else if (projectionType === 'stereographic') {
                        pos3D = projectStereographic(rotated, sphereRadius);
                    } else {
                        pos3D = projectOrthogonal(rotated);
                    }
                    southPoleMesh.position.set(pos3D[0] / 1000, pos3D[1] / 1000, pos3D[2] / 1000);
                }
            }
        }

        // Event listeners
        document.getElementById('fileInput').addEventListener('change', async (e) => {
            const file = e.target.files[0];
            if (!file) return;

            document.getElementById('loadingIndicator').style.display = 'block';

            const reader = new FileReader();
            reader.onload = (event) => {
                try {
                    const jsonData = JSON.parse(event.target.result);
                    loadSimulationData(jsonData);
                } catch (error) {
                    alert('Error loading file: ' + error.message);
                    console.error(error);
                } finally {
                    document.getElementById('loadingIndicator').style.display = 'none';
                }
            };
            reader.readAsText(file);
        });

        document.getElementById('snapshotSlider').addEventListener('input', (e) => {
            const index = parseInt(e.target.value);
            renderSnapshot(index);
        });

        document.getElementById('playPause').addEventListener('click', () => {
            isPlaying = !isPlaying;
            document.getElementById('playPause').textContent = isPlaying ? '⏸ Pause' : '▶ Play';

            if (isPlaying) {
                playbackInterval = setInterval(() => {
                    let nextIndex = currentSnapshotIndex + 1;
                    if (nextIndex >= simulationData.snapshots.length) {
                        nextIndex = 0;
                    }
                    document.getElementById('snapshotSlider').value = nextIndex;
                    renderSnapshot(nextIndex);
                }, 500);
            } else {
                clearInterval(playbackInterval);
            }
        });

        document.getElementById('rotationXW').addEventListener('input', (e) => {
            const val = parseFloat(e.target.value);
            document.getElementById('xwValue').textContent = val.toFixed(2);
            viewAngles.xw = val;
            updateView();
        });

        document.getElementById('rotationYW').addEventListener('input', (e) => {
            const val = parseFloat(e.target.value);
            document.getElementById('ywValue').textContent = val.toFixed(2);
            viewAngles.yw = val;
            updateView();
        });

        document.getElementById('rotationZW').addEventListener('input', (e) => {
            const val = parseFloat(e.target.value);
            document.getElementById('zwValue').textContent = val.toFixed(2);
            viewAngles.zw = val;
            updateView();
        });

        document.getElementById('resetView').addEventListener('click', () => {
            viewAngles = { xw: 0, yw: 0, zw: 0 };
            document.getElementById('rotationXW').value = 0;
            document.getElementById('rotationYW').value = 0;
            document.getElementById('rotationZW').value = 0;
            document.getElementById('xwValue').textContent = '0.0';
            document.getElementById('ywValue').textContent = '0.0';
            document.getElementById('zwValue').textContent = '0.0';
            updateView();
        });

        document.getElementById('pointSize').addEventListener('input', (e) => {
            document.getElementById('sizeValue').textContent = e.target.value;
            if (superfluidPoints) {
                superfluidPoints.material.size = parseFloat(e.target.value) * 0.01;
            }
        });

        document.getElementById('vortexSize').addEventListener('input', (e) => {
            document.getElementById('vortexSizeValue').textContent = e.target.value;
            // Rerender vortices with new size
            if (simulationData) {
                renderSnapshot(currentSnapshotIndex);
            }
        });

        document.getElementById('showPoles').addEventListener('change', updateView);

        document.getElementById('projectionSelect').addEventListener('change', updateView);

        // Animation loop
        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
            labelRenderer.render(scene, camera);
        }

        // Window resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            labelRenderer.setSize(window.innerWidth, window.innerHeight);
        });

        // Start
        animate();
    </script>
</body>
</html>
